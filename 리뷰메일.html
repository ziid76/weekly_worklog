<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>작업 내역 보고서: 주간 보고서 리뷰 메일 발송 기능</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; line-height: 1.6; color: #333; background-color: #f8f9fa; margin: 0; padding: 20px; }
        .container { max-width: 1000px; margin: auto; background: #fff; padding: 25px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.05); }
        h1, h2, h3 { color: #0056b3; border-bottom: 2px solid #0056b3; padding-bottom: 10px; }
        h1 { text-align: center; }
        .summary, .file-section { background-color: #fdfdfe; border: 1px solid #e9ecef; border-radius: 6px; padding: 20px; margin-bottom: 20px; }
        h3 { border-bottom: 1px solid #dee2e6; color: #17a2b8; }
        pre { background-color: #282c34; color: #abb2bf; padding: 15px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word; }
        code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
        .tag { display: inline-block; padding: 4px 8px; border-radius: 4px; font-size: 0.9em; font-weight: bold; }
        .tag-created { background-color: #28a745; color: white; }
        .tag-modified { background-color: #ffc107; color: #212529; }
    </style>
</head>
<body>
    <div class="container">
        <h1>작업 내역 보고서</h1>
        <h2>주간 보고서 리뷰 메일 발송 기능 구현</h2>

        <div class="summary">
            <h3>작업 요약</h3>
            <p>사용자의 요청에 따라, 개인별 주간 보고서에 대한 AI 리뷰 결과를 이메일로 발송하는 기능을 구현했습니다. 이 기능은 AWS SES를 사용하여 이메일을 보내며, `manage.py` 명령어를 통해 실행하고 `cron`으로 스케줄링할 수 있습니다.</p>
            <p><b>주요 변경 사항:</b></p>
            <ul>
                <li>AI 리뷰 결과를 저장하기 위한 `ReportReview` Django 모델을 추가했습니다.</li>
                <li>리뷰 생성 서비스 로직을 수정하여, 생성된 리뷰가 데이터베이스에 저장되도록 변경했습니다.</li>
                <li>AWS 서비스 연동을 위해 `boto3`와 `django-ses` 라이브러리를 추가하고 관련 설정을 구성했습니다.</li>
                <li>발송 대기 중인 리뷰를 찾아 사용자에게 이메일을 보내는 `send_review_notifications` 관리자 명령어를 생성했습니다.</li>
                <li>이메일 본문을 위한 HTML 템플릿을 작성했습니다.</li>
            </ul>
        </div>

        <div class="file-section">
            <h2>수정된 파일</h2>

            <h3><span class="tag tag-modified">Modified</span> reports/models.py</h3>
            <pre><code>from django.db import models
from django.contrib.auth.models import User
from teams.models import Team
from worklog.models import Worklog


class ReportReview(models.Model):
    """개인별 주간업무 AI 리뷰 결과"""
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='report_reviews', verbose_name="리뷰 대상자")
    year = models.IntegerField("년도")
    week_number = models.IntegerField("주차")
    review_content = models.JSONField("AI 리뷰 내용")
    notification_sent = models.BooleanField("알림 발송 여부", default=False)
    created_at = models.DateTimeField("생성일시", auto_now_add=True)
    updated_at = models.DateTimeField("수정일시", auto_now=True)

    class Meta:
        unique_together = ('user', 'year', 'week_number')
        ordering = ['-year', '-week_number', 'user']
        verbose_name = "AI 리뷰 결과"
        verbose_name_plural = "AI 리뷰 결과 목록"

    def __str__(self):
        return f"{self.user.username} - {self.year}년 {self.week_number}주차 리뷰"


class WeeklyReport(models.Model):
    """주간 집계 리포트"""
    year = models.IntegerField("년도")
    week_number = models.IntegerField("주차")
    title = models.CharField("리포트 제목", max_length=200)
    team = models.ForeignKey(Team, on_delete=models.CASCADE, related_name='weekly_reports', null=True, blank=True, verbose_name="대상 팀")
    editable = models.BooleanField("입력마감 여부", default=True)
    created_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='created_reports')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('year', 'week_number', 'team')
        ordering = ['-year', '-week_number']

    def __str__(self):
        team_name = self.team.name if self.team else "전체"
        return f"{self.year}년 {self.week_number}주차 주간 리포트 ({team_name})"

    @property
    def get_worklog_count(self):
        """리포트에 작성된 주간업무 수"""        
        return Worklog.objects.filter(year=self.year, week_number=self.week_number).count


    @property
    def week_start_date(self):
        """해당 주의 월요일 날짜"""
        import datetime
        return datetime.date.fromisocalendar(self.year, self.week_number, 1)

    @property
    def week_end_date(self):
        """해당 주의 일요일 날짜"""
        import datetime
        return self.week_start_date + datetime.timedelta(days=4)

    @property
    def next_week_start_date(self):
        import datetime
        return self.week_start_date + datetime.timedelta(days=7)

    @property
    def next_week_end_date(self):
        import datetime
        return self.week_start_date + datetime.timedelta(days=11)


    @property
    def month_week_display_with_year(self):
        return f"{self.month_week_display} ({self.year}년 {self.week_number}주차)"

    @property
    def month_week_display(self):
        """'7월 1주차'와 같은 형식으로 월별 주차를 반환합니다."""
        import datetime
        start_date = self.week_start_date
        end_date = self.week_end_date
        
        # 주의 시작과 끝이 같은 달인 경우
        if start_date.month == end_date.month:
            # 해당 월의 첫 번째 월요일을 찾아서 몇 번째 주인지 계산
            first_monday = start_date.replace(day=1)
            while first_monday.weekday() != 0:  # 0 = 월요일
                first_monday += datetime.timedelta(days=1)
            
            week_diff = (start_date - first_monday).days // 7 + 1
            return f"{start_date.month}월 {week_diff}주차"
        else:
            # 주가 두 달에 걸쳐있는 경우, 더 많은 날이 포함된 달 기준
            if start_date.day <= 3:  # 월요일~수요일이 이전 달
                month = end_date.month
                first_monday = end_date.replace(day=1)
                while first_monday.weekday() != 0:
                    first_monday += datetime.timedelta(days=1)
                week_diff = (end_date - first_monday).days // 7 + 1
            else:  # 목요일~일요일이 다음 달
                month = start_date.month
                first_monday = start_date.replace(day=1)
                while first_monday.weekday() != 0:
                    first_monday += datetime.timedelta(days=1)
                week_diff = (start_date - first_monday).days // 7 + 1
            
            return f"{month}월 {week_diff}주차"

class WeeklyReportComment(models.Model):
    """주간 리포트 코멘트"""
    report = models.ForeignKey(WeeklyReport, on_delete=models.CASCADE, related_name='comments')
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    content = models.TextField("코멘트 내용")
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['created_at']

    def __str__(self):
        return f"{self.report} - {self.author.username}"


class WeeklyReportPersonalComment(models.Model):
    """담당자별 업무 코멘트"""
    report = models.ForeignKey(WeeklyReport, on_delete=models.CASCADE, related_name='personal_comments')
    target_user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='personal_report_comments')
    content = models.TextField("업무 코멘트")
    created_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='created_personal_report_comments')
    created_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        ordering = ['created_at']

    def __str__(self):
        return f"{self.report} - {self.target_user.username}"


class TeamWeeklyReport(models.Model):
    """팀별 주간 리포트"""
    team = models.ForeignKey(Team, on_delete=models.CASCADE, related_name='team_weekly_reports')
    year = models.IntegerField("년도")
    week_number = models.IntegerField("주차")
    title = models.CharField("리포트 제목", max_length=200)
    summary = models.TextField("주간 요약", blank=True)
    achievements = models.TextField("주요 성과", blank=True)
    issues = models.TextField("이슈 및 문제점", blank=True)
    next_week_plan = models.TextField("다음 주 계획", blank=True)
    created_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='created_team_reports')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('team', 'year', 'week_number')
        ordering = ['-year', '-week_number']

    def __str__(self):
        return f"{self.team.name} - {self.year}년 {self.week_number}주차"

    @property
    def week_start_date(self):
        """해당 주의 월요일 날짜"""
        import datetime
        return datetime.date.fromisocalendar(self.year, self.week_number, 1)

    @property
    def week_end_date(self):
        """해당 주의 일요일 날짜"""
        import datetime
        return self.week_start_date + datetime.timedelta(days=6)

    @property
    def month_week_display_with_year(self):
        return f"{self.month_week_display} ({self.year}년 {self.week_number}주차)"

    @property
    def month_week_display(self):
        """'7월 1주차'와 같은 형식으로 월별 주차를 반환합니다."""
        import datetime
        start_date = self.week_start_date
        end_date = self.week_end_date
        
        # 주의 시작과 끝이 같은 달인 경우
        if start_date.month == end_date.month:
            # 해당 월의 첫 번째 월요일을 찾아서 몇 번째 주인지 계산
            first_monday = start_date.replace(day=1)
            while first_monday.weekday() != 0:  # 0 = 월요일
                first_monday += datetime.timedelta(days=1)
            
            week_diff = (start_date - first_monday).days // 7 + 1
            return f"{start_date.month}월 {week_diff}주차"
        else:
            # 주가 두 달에 걸쳐있는 경우, 더 많은 날이 포함된 달 기준
            if start_date.day <= 3:  # 월요일~수요일이 이전 달
                month = end_date.month
                first_monday = end_date.replace(day=1)
                while first_monday.weekday() != 0:
                    first_monday += datetime.timedelta(days=1)
                week_diff = (end_date - first_monday).days // 7 + 1
            else:  # 목요일~일요일이 다음 달
                month = start_date.month
                first_monday = start_date.replace(day=1)
                while first_monday.weekday() != 0:
                    first_monday += datetime.timedelta(days=1)
                week_diff = (start_date - first_monday).days // 7 + 1
            
            return f"{month}월 {week_diff}주차"
</code></pre>
            <h3><span class="tag tag-modified">Modified</span> app/services/report_review.py</h3>
            <pre><code>"""AI review service for weekly reports."""

from __future__ import annotations

import json
import logging
import os
from dataclasses import dataclass
from datetime import date, timedelta
from typing import Any, Dict, Iterable, List, Optional, Sequence

from django.conf import settings
from django.contrib.auth import get_user_model

from worklog.models import Worklog
from reports.models import ReportReview

from google import genai
from google.api_core import exceptions as google_exceptions



User = get_user_model()
logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class WeekWindow:
    """Container for a single ISO week slice."""

    year: int
    week_number: int
    week_start: date


def review_last_4_weeks(user: User, as_of: Optional[date] = None) -> Dict[str, Any]:
    """Run Gemini-based audit for the user's latest four weeks of worklogs.

    Args:
        user: Authenticated user requesting their own report review.
        as_of: Optional anchor date; defaults to today when omitted.

    Returns:
        Parsed JSON dictionary produced by Gemini. Falls back to a guarded
        structure when the API is unavailable or the response cannot be parsed.
    """

    anchor = as_of or date.today()
    weeks = _compute_weeks(anchor)
    entries = _collect_worklogs(user, weeks)
    logger.debug("Collected %s weeks for review", len(entries))

    prompt = _build_prompt(user, entries, anchor)
    logger.debug("Generated prompt length=%s", len(prompt))

    api_key = _resolve_api_key()
    if not api_key:
        logger.error("Gemini API key is not configured")
        return _fallback_result("API key not configured")

    if not genai:  # pragma: no cover - depends on optional dependency
        logger.error("google-genai package is not installed")
        return _fallback_result("google-genai package not installed")

    client = genai.Client(api_key=api_key)
    model_name = getattr(settings, "GEMINI_MODEL_NAME", "gemini-pro")
    timeout_seconds = getattr(settings, "GEMINI_TIMEOUT", 30)

    full_prompt = f"{_system_instruction()}\n\n{prompt}"

    try:
        logger.info("Requesting Gemini review for user=%s model=%s", user.pk, model_name)
        response = client.models.generate_content(
            model=model_name,
            contents=full_prompt,
            config=_generation_config(),
        )
    except tuple(_handled_exceptions()) as exc:  # type: ignore[arg-type]
        logger.exception("Gemini request failed: %s", exc)
        return _fallback_result(str(exc))
    except Exception as exc:  # pragma: no cover - defensive
        logger.exception("Unexpected Gemini error: %s", exc)
        return _fallback_result("unexpected_error")

    raw_text = _extract_text(response)
    if not raw_text:
        logger.error("Gemini response missing text payload")
        return _fallback_result("empty_response")

    try:
        payload = json.loads(raw_text)
    except json.JSONDecodeError as exc:
        logger.exception("Malformed JSON from Gemini: %s", exc)
        fallback = _fallback_result("malformed_json")
        fallback["raw"] = raw_text
        payload = fallback
    
    # 리뷰 결과를 데이터베이스에 저장
    try:
        review_year, review_week, _ = anchor.isocalendar()
        ReportReview.objects.update_or_create(
            user=user,
            year=review_year,
            week_number=review_week,
            defaults={
                'review_content': payload,
                'notification_sent': False  # 새 리뷰가 생성되었으므로 알림 미발송 상태로 설정
            }
        )
        logger.info("Saved AI review for user=%s, week=%s-%s", user.pk, review_year, review_week)
    except Exception as e:
        logger.exception("Failed to save AI review to database: %s", e)

    return payload


def _handled_exceptions() -> Sequence[type]:
    handlers: List[type] = [TimeoutError]
    if google_exceptions:
        handlers.append(google_exceptions.GoogleAPIError)
    try:
        from requests import exceptions as requests_exceptions
    except ImportError:  # pragma: no cover - requests bundled with SDK
        requests_exceptions = None
    if requests_exceptions:
        handlers.extend(
            [
                requests_exceptions.Timeout,
                requests_exceptions.ConnectionError,
                requests_exceptions.HTTPError,
            ]
        )
    return tuple(handlers)


def _compute_weeks(anchor: date) -> List[WeekWindow]:
    monday = anchor - timedelta(days=anchor.weekday())
    windows: List[WeekWindow] = []
    for offset in range(3, -1, -1):
        week_start = monday - timedelta(weeks=offset)
        iso_year, iso_week, _ = week_start.isocalendar()
        windows.append(WeekWindow(year=iso_year, week_number=iso_week, week_start=week_start))
    return windows


def _collect_worklogs(user: User, windows: Iterable[WeekWindow]) -> List[Dict[str, Any]]:
    window_list = list(windows)
    years = {window.year for window in window_list}
    week_numbers = {window.week_number for window in window_list}

    queryset = (
        Worklog.objects.filter(author=user, year__in=years, week_number__in=week_numbers)
        .only("year", "week_number", "this_week_work", "next_week_plan")
    )
    worklog_map = {(worklog.year, worklog.week_number): worklog for worklog in queryset}

    entries: List[Dict[str, Any]] = []
    for window in window_list:
        worklog = worklog_map.get((window.year, window.week_number))
        entries.append(
            {
                "year": window.year,
                "week_number": window.week_number,
                "week_start": window.week_start,
                "week_end": window.week_start + timedelta(days=6),
                "this_week_work": (worklog.this_week_work if worklog else ""),
                "next_week_plan": (worklog.next_week_plan if worklog else ""),
                "has_worklog": worklog is not None,
            }
        )
    return entries


def _resolve_api_key() -> Optional[str]:
    return os.getenv("GEMINI_API_KEY") or os.getenv("GOOGLE_API_KEY")


def _system_instruction() -> str:
    return (
        "당신은 PMO 보조분석가입니다. 제공되는 4주간의 주간보고(금주 실적/차주 계획)를 기반으로 "
        "정합성, 누락, 지연, 리스크를 점검하고 실질적인 개선 권고를 제시하세요."
    )


def _build_prompt(user: User, entries: Sequence[Dict[str, Any]], anchor_date: date) -> str:
    profile = getattr(user, "profile", None)
    display_name = getattr(profile, "get_korean_name", None)
    if callable(display_name):
        display_name = display_name()
    elif display_name:
        display_name = str(display_name)
    else:
        display_name = user.get_full_name() or user.username

    lines = [
        f"분석 기준일: {anchor_date.isoformat()}",
        "분석 대상자: {name} ({username})".format(name=display_name, username=user.username),
        "요약 기간: 최근 4주 (최신 주 포함)",
        "각 주차는 금주 실적과 차주 계획으로 구성되어 있습니다.",
         "",
    ]

    for entry in entries:
        title = (
            f"### {entry['year']}년 {entry['week_number']}주차"
            f" ({entry['week_start'].isoformat()} ~ {entry['week_end'].isoformat()})"
        )
        lines.extend([title])
        if entry["has_worklog"]:
            lines.append("- 금주 실적:")
            lines.append(entry["this_week_work"].strip() or "(내용은 공백이지만 보고서는 존재)")
            lines.append("- 차주 계획:")
            lines.append(entry["next_week_plan"].strip() or "(내용은 공백이지만 계획이 비어있음)")
        else:
            lines.append("- 이번주는 휴무여서 금주 실적은 작성하지 않았습니다.")
            lines.append("- 이번주는 휴무여서 차주 계획은 작성하지 않았습니다. 전주의 차주계획을 금주의 차주계획으로 간주합니다.")
        lines.append("")

    lines.extend(
        [
            "분석 지시:",
            "1. 4주 흐름을 살펴 금주 실적 대비 차주 계획의 연계성과 정합성을 평가하세요.",
            "2. 누락된 계획, 반복 지연, 근거 부족, 리스크 징후를 찾아주세요.",
            "3. 제공된 출력 스키마에 맞춰 JSON으로만 응답하세요.",
            "4. 모든 수치 필드에는 숫자 자료를 채워주세요. 완료율은 100%를 넘길 수 없습니다. 데이터 없으면 0으로 입력하세요.",
            "5. 권고 사항은 실행 가능한 행동으로 제시하세요.",
            "6. 각 'metric' 항목은 'value' (숫자)와 'details' (문자열 배열)을 포함해야 합니다. 'details'에는 해당 지표의 근거가 되는 항목들을 상세한 목록으로 나열하세요.(ex, value=10이면, details에 10개를 목록으로 포함)",
            "7. 'mismatches' 는 중복된 내용을 포함하지 마세요.",
            "8. 'mismatches' 는 지난 주의 계획에 있으나 금주의 실적에는 누락된 항목, 지난 계획의 완료 일정과 실적이 지연되거나 차이가 나는 항목 등을 분석해서 제시하세요.",
            ""
        ]
    )

    return "\n".join(lines)


def _request_options(timeout_seconds: int) -> Optional[Any]:
    if timeout_seconds <= 0:
        return None
    if not genai:  # pragma: no cover - handled earlier
        return None

    types_module = getattr(genai, "types", None)
    if types_module:
        request_options_cls = getattr(types_module, "RequestOptions", None)
        if request_options_cls:
            try:
                return request_options_cls(timeout=timeout_seconds)
            except TypeError:  # pragma: no cover - defensive
                pass
        generate_request_cls = getattr(types_module, "GenerateContentRequest", None)
        if generate_request_cls:
            nested = getattr(generate_request_cls, "RequestOptions", None)
            if nested:
                try:
                    return nested(timeout=timeout_seconds)
                except TypeError:  # pragma: no cover - defensive
                    pass
    return {"timeout": timeout_seconds}


def _generation_config() -> Any:
    if not genai:  # pragma: no cover - handled earlier
        return None

    schema = _response_schema()
    # Fallback for unexpected SDK layout    
    return {
        "temperature": 0.2,
        "response_mime_type": "application/json",
        "response_schema": schema,
    }


def _response_schema() -> Dict[str, Any]:
    # Schema for metrics that are counts
    count_metric = {
        "type": "object",
        "properties": {
            "value": {"type": "integer"},
            "details": {"type": "array", "items": {"type": "string"}},
        },
        "required": ["value", "details"],
    }
    # Schema for metrics that are rates or averages
    float_metric = {
        "type": "object",
        "properties": {
            "value": {"type": "number"},
            "details": {"type": "array", "items": {"type": "string"}},
        },
        "required": ["value", "details"],
    }
    return {
        "type": "object",
        "properties": {
            "summary": {"type": "string"},
            "metrics": {
                "type": "object",
                "properties": {
                    "planned_count": count_metric,
                    "done_count": count_metric,
                    "completion_rate": float_metric,
                    "avg_delay_days": float_metric,
                    "carryover_count": count_metric,
                    "missing_evidence_count": count_metric,
                },
                "required": [
                    "planned_count",
                    "done_count",
                    "completion_rate",
                    "avg_delay_days",
                    "carryover_count",
                    "missing_evidence_count",
                ],
            },
            "mismatches": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "plan_item": {"type": "string"},
                        "issue": {"type": "string"},
                        "evidence_needed": {
                            "type": "array",
                            "items": {"type": "string"},
                        },
                    },
                    "required": ["plan_item", "issue", "evidence_needed"],
                },
            },
            "risks": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "description": {"type": "string"},
                        "status": {
                            "type": "string",
                            "enum": ["지속", "완화", "악화"],
                        },
                        "owner": {"type": "string"},
                        "next_action": {"type": "string"},
                        "due": {"type": "string", "format": "date"},
                    },
                    "required": ["description", "status", "owner", "next_action", "due"],
                },
            },
            "recommendations": {
                "type": "array",
                "items": {"type": "string"},
            },
            "error": {"type": "string"},
        },
        "required": ["summary", "metrics", "mismatches", "risks", "recommendations"],
    }


def _fallback_result(reason: str) -> Dict[str, Any]:
    base = {
        "summary": "AI 점검실패",
        "metrics": {
            "planned_count": {"value": 0, "details": []},
            "done_count": {"value": 0, "details": []},
            "completion_rate": {"value": 0.0, "details": []},
            "avg_delay_days": {"value": 0.0, "details": []},
            "carryover_count": {"value": 0, "details": []},
            "missing_evidence_count": {"value": 0, "details": []},
        },
        "mismatches": [],
        "risks": [],
        "recommendations": [],
        "error": reason,
    }
    return base


def _extract_text(response: Any) -> str:
    text = getattr(response, "text", None)
    if isinstance(text, str) and text.strip():
        return text

    candidates = getattr(response, "candidates", None)
    if candidates:
        for candidate in candidates:
            content = getattr(candidate, "content", None)
            if not content:
                continue
            parts = getattr(content, "parts", None)
            if not parts:
                continue
            texts = [getattr(part, "text", "") for part in parts if getattr(part, "text", "")]
            if texts:
                return "\n".join(texts)
    return ""

def _guide_response_schema() -> Dict[str, Any]:
    """Returns the JSON schema for the writing guide response."""
    item_schema = {
        "type": "object",
        "properties": {
            "title": {"type": "string"},
            "content": {"type": "string"},
        },
        "required": ["title", "content"],
    }
    return {
        "type": "object",
        "properties": {
            "suggested_this_week_work": {
                "type": "array",
                "items": item_schema,
            },
            "suggested_next_week_plan": {
                "type": "array",
                "items": item_schema,
            },
        },
        "required": ["suggested_this_week_work", "suggested_next_week_plan"],
    }

def _guide_system_instruction() -> str:
    """Returns the system instruction for the writing guide generation."""
    return (
        "당신은 사용자가 주간 업무 보고서를 잘 작성하도록 돕는 유능한 조수입니다. "
        "과거의 보고서 내용을 기반으로, 새로 작성할 보고서에 포함되어야 할 항목을 추천합니다."
    )

def _build_guide_prompt(user: User, worklogs: Sequence[Worklog]) -> str:
    """Builds the prompt for generating the writing guide."""
    profile = getattr(user, "profile", None)
    display_name = getattr(profile, "get_korean_name", None)
    if callable(display_name):
        display_name = display_name()
    elif display_name:
        display_name = str(display_name)
    else:
        display_name = user.get_full_name() or user.username

    lines = [
        f"분석 대상자: {display_name} ({user.username})",
        "분석 대상: 최근에 작성된 최대 4개의 주간 보고서",
        "",
    ]

    if not worklogs:
        lines.append("분석할 이전 주간 보고서가 없습니다.")
    else:
        lines.append("### 이전 주간 보고서 내용 ###")
        for worklog in worklogs:
            title = f"- {worklog.year}년 {worklog.week_number}주차 ({worklog.week_start_date.isoformat()} ~ {worklog.week_end_date.isoformat()})"
            lines.append(title)
            lines.append("  - 금주 실적:")
            lines.append(f"    {worklog.this_week_work.strip() or '(내용 없음)'}")
            lines.append("  - 차주 계획:")
            lines.append(f"    {worklog.next_week_plan.strip() or '(내용 없음)'}")
            lines.append("")

    lines.extend(
        [
            "### 작성 가이드 생성 지시 ###",
            "1. 위에 제공된 '이전 주간 보고서 내용'을 분석하여, 새로 작성할 주간 보고서의 '금주 실적'과 '차주 계획'에 들어갈 내용을 추천해주세요.",
            "2. 각 추천 항목은 'title'과 'content' 필드를 가진 JSON 객체 형태로 반환해야 합니다.",
            "   - 'title'과 'content'는 개조식으로 작성되어야 합니다",
            "   - 'title'은 추천 항목의 핵심 내용을 요약한 짧은 문구입니다. (예: '지난주 계획 이월', '신규 프로젝트 시작')",
            "   - 'content'는 'title'에 대한 상세 설명 또는 구체적인 작성 가이드입니다. ",
            "3. '금주 실적' 추천 항목:",
            "   - 가장 최근 보고서의 '차주 계획'이 이번 주에 잘 이행되었는지 확인하고, 그 결과를 바탕으로 실적 항목을 제안하세요.",
            "   - 여러 주에 걸쳐 계속 언급되는 항목이나 지연된 항목이 있다면, 진행 상황을 보고하도록 제안하세요.",
            "4. '차주 계획' 추천 항목:",
            "   - 분석된 모든 보고서의 흐름을 파악하여, 앞으로 해야 할 논리적인 다음 단계를 '차주 계획'으로 제안하세요.",
            "   - 예를 들어, 'X 개발 완료'가 실적이라면, 'X 테스트 및 배포'를 계획으로 제안할 수 있습니다.",
            "5. 제안하는 각 항목의 'content'는  구체적인 행동 지침이어야 합니다.",
            "6. 제공된 JSON 출력 스키마에 맞춰서만 응답해야 합니다. 다른 설명은 절대 추가하지 마세요.",
            "7. 추천할 내용이 없다면 빈 배열 `[]`을 반환하세요.",
        ]
    )
    return "\n".join(lines)


def generate_writing_guide(user: User) -> Dict[str, Any]:
    """Generate a writing guide for the user's new worklog based on past reports."""
    
    # 1. Collect last 4 worklogs
    worklogs = list(Worklog.objects.filter(author=user).order_by('-year', '-week_number')[:4])
    logger.debug("Collected %s past worklogs for writing guide", len(worklogs))

    # 2. Build the prompt
    prompt = _build_guide_prompt(user, worklogs)
    logger.debug("Generated guide prompt length=%s", len(prompt))

    # 3. Check API key and dependencies
    api_key = _resolve_api_key()
    if not api_key:
        logger.error("Gemini API key is not configured")
        return {"error": "API 키가 설정되지 않았습니다."}

    if not genai:
        logger.error("google-genai package is not installed")
        return {"error": "google-genai 패키지가 설치되지 않았습니다."}

    # 4. Set up Gemini client and call API
    client = genai.Client(api_key=api_key)
    model_name = getattr(settings, "GEMINI_MODEL_NAME", "gemini-pro")
    
    generation_config = {
        "temperature": 0.3,
        "response_mime_type": "application/json",
        "response_schema": _guide_response_schema(),
    }
    
    full_prompt = f"{_guide_system_instruction()}\n\n{prompt}"

    try:
        logger.info("Requesting Gemini writing guide for user=%s", user.pk)
        response = client.models.generate_content(
            model=model_name,
            contents=full_prompt,
            config=generation_config,
        )
    except tuple(_handled_exceptions()) as exc:
        logger.exception("Gemini guide request failed: %s", exc)
        return {"error": f"AI 서비스 요청에 실패했습니다: {exc}"}
    except Exception:
        logger.exception("Unexpected Gemini error for guide request")
        return {"error": "예상치 못한 AI 서비스 오류가 발생했습니다."}

    # 5. Parse and return response
    raw_text = _extract_text(response)
    if not raw_text:
        logger.error("Gemini guide response missing text payload")
        return {"error": "AI로부터 비어 있는 응답을 받았습니다."}

    try:
        payload = json.loads(raw_text)
        # Add report identifiers to the payload for context
        payload['based_on_reports'] = [f"{w.year}-W{w.week_number}" for w in worklogs]
        return payload
    except json.JSONDecodeError:
        logger.exception("Malformed JSON from Gemini for guide: %s", raw_text)
        return {"error": "AI가 잘못된 형식의 응답을 반환했습니다."}

__all__ = ["review_last_4_weeks", "generate_writing_guide"]
</code></pre>
            <h3><span class="tag tag-modified">Modified</span> config/settings.py</h3>
            <pre><code>from pathlib import Path
import os
from dotenv import load_dotenv

load_dotenv()

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/


# .env에서 환경변수 가져오기
SECRET_KEY = os.environ.get('SECRET_KEY')

DEBUG = int(os.environ.get('DEBUG', 1))

if os.environ.get('DJANGO_ALLOWED_HOSTS'):
    ALLOWED_HOSTS = os.environ.get('DJANGO_ALLOWED_HOSTS').split(',')
else:
    ALLOWED_HOSTS = ['127.0.0.1', 'localhost', 'itms.samchully.co.kr']


CSRF_TRUSTED_ORIGINS = os.environ.get(
    "DJANGO_CSRF_TRUSTED_ORIGINS",
    "https://itms.samchully.co.kr"
).split(",")

SITE_URL ="https://itms.samchully.co.kr"

SESSION_COOKIE_SECURE = True
CSRF_COOKIE_SECURE = True

GEMINI_MODEL_NAME = os.getenv("GEMINI_MODEL_NAME", "gemini-1.5-pro")
GEMINI_TIMEOUT = int(os.getenv("GEMINI_TIMEOUT", "30"))


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'app',
    'accounts',
    'worklog',
    'task',
    'teams',
    'notifications',
    'dashboard',
    'reports',
    'monitor',
    'service',
    'django_summernote',  # 임시 비활성화
    'django_ses',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'accounts.middleware.FirstLoginMiddleware',  # 첫 로그인 체크 미들웨어
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'notifications.context_processors.notifications',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

LOGIN_REDIRECT_URL = 'dashboard'
LOGOUT_REDIRECT_URL = 'login'


# Email Settings for AWS SES
EMAIL_BACKEND = 'django_ses.SESBackend'
AWS_SES_REGION_NAME = os.environ.get('AWS_SES_REGION_NAME', 'ap-northeast-2')
AWS_SES_ACCESS_KEY_ID = os.environ.get('AWS_SES_ACCESS_KEY_ID')
AWS_SES_SECRET_ACCESS_KEY = os.environ.get('AWS_SES_SECRET_ACCESS_KEY')
DEFAULT_FROM_EMAIL = os.environ.get('DEFAULT_FROM_EMAIL', 'gemini@example.com')


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases



DATABASES = {
    'default': {
        'ENGINE': os.environ.get("SQL_ENGINE", 'django.db.backends.sqlite3'),
        'NAME': os.environ.get('SQL_DATABASE', os.path.join(BASE_DIR, 'db.sqlite3')),
        'USER': os.environ.get('SQL_USER', 'user'),
        'PASSWORD': os.environ.get('SQL_PASSWORD', 'password'),
        'HOST': os.environ.get('SQL_HOST', 'localhost'),
        'PORT': os.environ.get("SQL_PORT", '5432'),
    }


}

# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'ko-kr'

TIME_ZONE = 'Asia/Seoul'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/


STATIC_URL = '/static/'
STATIC_ROOT = '/app/staticfiles'  # nginx와 공유하는 경로로 지정
if DEBUG:
    STATICFILES_DIRS = [BASE_DIR / 'static']
# Media files
MEDIA_URL = '/media/'
MEDIA_ROOT = '/app/media'         # nginx와 공유하는 경로로 지정

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Summernote 설정
SUMMERNOTE_CONFIG = {
    'iframe': True,
    'summernote': {
        'airMode': False,
        'width': '100%',
        'height': '400',
        'lang': 'ko-KR',
        'toolbar': [
            ['style', ['style']],
            ['font', ['bold', 'underline', 'clear']],
            ['fontname', ['fontname']],
            ['color', ['color']],
            ['para', ['ul', 'ol', 'paragraph']],
            ['table', ['table']],
            ['insert', ['link', 'picture', 'video']],
            ['view', ['fullscreen', 'codeview', 'help']],
        ],
    },
    'disable_attachment': False,
    'attachment_require_authentication': True,
}
</code></pre>
            <h3><span class="tag tag-modified">Modified</span> requirements.txt</h3>
            <pre><code>aiohappyeyeballs==2.6.1
aiohttp==3.12.15
aiosignal==1.4.0
annotated-types==0.7.0
anyio==4.11.0
asgiref==3.8.1
asttokens==3.0.0
attrs==25.1.0
beautifulsoup4==4.12.3
bleach==6.2.0
CacheControl==0.14.1
cachetools==5.5.0
certifi==2025.1.31
cffi==1.17.1
charset-normalizer==3.4.0
colorama==0.4.6
comm==0.2.2
cryptography==44.0.0
debugpy==1.8.9
decorator==5.1.1
Django==5.1.6
django-cors-headers==4.7.0
django-markdownx==4.0.9
django-summernote==0.8.20.0
dnspython==2.7.0
et_xmlfile==2.0.0
executing==2.1.0
frozenlist==1.8.0
genai==2.1.0
google-api-core==2.25.2
google-auth==2.41.1
google-genai==1.41.0
googleapis-common-protos==1.70.0
grpcio==1.68.1
grpcio-status==1.68.1
gunicorn==21.2.0
h11==0.16.0
httpcore==1.0.9
httplib2==0.22.0
httpx==0.28.1
idna==3.10
inflection==0.5.1
ipykernel==6.29.5
ipython==8.30.0
jedi==0.19.2
jupyter_client==8.6.3
jupyter_core==5.8.1
load-dotenv==0.1.0
lxml==6.0.0
Markdown==3.8.2
matplotlib-inline==0.1.7
msgpack==1.1.0
multidict==6.6.4
nest-asyncio==1.6.0
numpy==2.2.2
openai==0.27.10
openpyxl==3.1.5
outcome==1.3.0.post0
packaging==24.2
pandas==2.2.3
parso==0.8.4
pexpect==4.9.0
pillow==11.3.0
platformdirs==4.3.8
postgres==4.0
prompt_toolkit==3.0.48
propcache==0.4.0
proto-plus==1.25.0
protobuf==5.29.1
psutil==6.1.0
psycopg2-binary==2.9.10
psycopg2-pool==1.2
ptyprocess==0.7.0
pure_eval==0.2.3
pyairtable==3.0.1
pyasn1==0.6.1
pyasn1_modules==0.4.1
pycparser==2.22
pydantic==2.10.6
pydantic_core==2.27.2
Pygments==2.18.0
pyparsing==3.2.0
PySocks==1.7.1
python-dateutil==2.9.0.post0
python-dotenv==1.1.0
python-pptx==1.0.2
pytz==2025.1
pyzmq==26.2.0
regex==2025.9.18
requests==2.32.3
rsa==4.9
six==1.16.0
sniffio==1.3.1
sortedcontainers==2.4.0
soupsieve==2.6
sqlparse==0.5.3
stack-data==0.6.3
tabulate==0.9.0
tenacity==9.1.2
tiktoken==0.3.3
tornado==6.4.2
traitlets==5.14.3
trio==0.29.0
trio-websocket==0.12.1
typing_extensions==4.12.2
tzdata==2025.1
uritemplate==4.1.1
urllib3==2.2.3
wcwidth==0.2.13
webencodings==0.5.1
websocket-client==1.8.0
websockets==15.0.1
wsproto==1.2.0
xlsxwriter==3.2.5
yarl==1.21.0
boto3>=1.34.0
django-ses>=3.0.0
</code></pre>
        </div>

        <div class="file-section">
            <h2>생성된 파일</h2>

            <h3><span class="tag tag-created">Created</span> mailing/mailer.py</h3>
            <pre><code>from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.conf import settings
from django.contrib.auth.models import User
from reports.models import ReportReview
import logging

logger = logging.getLogger(__name__)

def send_review_notification(review: ReportReview):
    """AI 리뷰 결과를 사용자에게 이메일로 발송합니다."""
    user = review.user
    subject = f"[{user.username}님] {review.year}년 {review.week_number}주차 주간보고서 AI 리뷰 결과 안내"

    if not user.email:
        logger.warning(f"User {user.username} (ID: {user.id}) has no email address. Skipping notification for review {review.id}.")
        return

    context = {
        'review': review.review_content,
        'user': user,
        'year': review.year,
        'week_number': review.week_number,
        'site_url': settings.SITE_URL,
    }

    # 이메일 본문을 HTML 템플릿으로 렌더링
    html_message = render_to_string('emails/review_notification.html', context)
    
    # 이메일 발송
    try:
        send_mail(
            subject=subject,
            message='',  # HTML 이메일에서는 plain text message는 비워둡니다.
            from_email=settings.DEFAULT_FROM_EMAIL,
            recipient_list=[user.email],
            html_message=html_message,
            fail_silently=False,
        )
        logger.info(f"Successfully sent review notification email to {user.email} for review {review.id}.")
    except Exception as e:
        logger.error(f"Failed to send email to {user.email} for review {review.id}. Error: {e}", exc_info=True)
        # 예외를 다시 발생시켜 호출한 쪽(관리 명령어)에서 처리하도록 함
        raise
</code></pre>
            <h3><span class="tag tag-created">Created</span> templates/emails/review_notification.html</h3>
            <pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang="ko"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;{{ year }}년 {{ week_number }}주차 AI 리뷰 결과&lt;/title&gt;
    &lt;style&gt;
        body {
            font-family: 'Malgun Gothic', '맑은 고딕', sans-serif;
            line-height: 1.6;
            color: #333;
            background-color: #f4f4f4;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 700px;
            margin: auto;
            background: #fff;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3 {
            color: #2c3e50;
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .header h1 {
            font-size: 24px;
            color: #3498db;
            border: none;
        }
        .summary {
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            border-left: 5px solid #3498db;
        }
        .section {
            margin-bottom: 25px;
        }
        ul {
            padding-left: 20px;
            list-style-type: disc;
        }
        li {
            margin-bottom: 8px;
        }
        .metrics-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .metrics-table th, .metrics-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        .metrics-table th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .footer {
            margin-top: 30px;
            text-align: center;
            font-size: 12px;
            color: #777;
        }
        .footer a {
            color: #3498db;
            text-decoration: none;
        }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class="container"&gt;
        &lt;div class="header"&gt;
            &lt;h1&gt;주간보고서 AI 리뷰 결과&lt;/h1&gt;
            &lt;p&gt;{{ user.username }}님의 {{ year }}년 {{ week_number }}주차 보고서에 대한 AI 리뷰입니다.&lt;/p&gt;
        &lt;/div&gt;

        {% if review.summary %}
        &lt;div class="section summary"&gt;
            &lt;h2&gt;종합 요약&lt;/h2&gt;
            &lt;p&gt;{{ review.summary }}&lt;/p&gt;
        &lt;/div&gt;
        {% endif %}

        {% if review.recommendations %}
        &lt;div class="section"&gt;
            &lt;h3&gt;개선 권고 사항&lt;/h3&gt;
            &lt;ul&gt;
                {% for item in review.recommendations %}
                &lt;li&gt;{{ item }}&lt;/li&gt;
                {% endfor %}
            &lt;/ul&gt;
        &lt;/div&gt;
        {% endif %}

        {% if review.mismatches %}
        &lt;div class="section"&gt;
            &lt;h3&gt;계획-실적 불일치 항목&lt;/h3&gt;
            &lt;ul&gt;
                {% for item in review.mismatches %}
                &lt;li&gt;
                    &lt;strong&gt;{{ item.plan_item }}&lt;/strong&gt;: {{ item.issue }}
                    {% if item.evidence_needed %}
                        (필요 근거: {{ item.evidence_needed|join:", " }})
                    {% endif %}
                &lt;/li&gt;
                {% endfor %}
            &lt;/ul&gt;
        &lt;/div&gt;
        {% endif %}

        {% if review.metrics %}
        &lt;div class="section"&gt;
            &lt;h3&gt;주요 지표&lt;/h3&gt;
            &lt;table class="metrics-table"&gt;
                &lt;tr&gt;
                    &lt;th&gt;지표&lt;/th&gt;
                    &lt;th&gt;수치&lt;/th&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td&gt;계획 항목 수&lt;/td&gt;
                    &lt;td&gt;{{ review.metrics.planned_count.value }}&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td&gt;완료 항목 수&lt;/td&gt;
                    &lt;td&gt;{{ review.metrics.done_count.value }}&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td&gt;계획 이행률&lt;/td&gt;
                    &lt;td&gt;{{ review.metrics.completion_rate.value|floatformat:2 }}%&lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td&gt;이월된 항목 수&lt;/td&gt;
                    &lt;td&gt;{{ review.metrics.carryover_count.value }}&lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/div&gt;
        {% endif %}

        {% if review.error and review.error != "None" %}
        &lt;div class="section summary"&gt;
            &lt;h2&gt;오류&lt;/h2&gt;
            &lt;p&gt;AI 리뷰 생성 중 오류가 발생했습니다: {{ review.error }}&lt;/p&gt;
        &lt;/div&gt;
        {% endif %}

        &lt;div class="footer"&gt;
            &lt;p&gt;이 메일은 자동 발송되었습니다.&lt;/p&gt;
            &lt;p&gt;&lt;a href="{{ site_url }}"&gt;ITMS 바로가기&lt;/a&gt;&lt;/p&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
            <h3><span class="tag tag-created">Created</span> reports/management/commands/send_review_notifications.py</h3>
            <pre><code>import logging
from django.core.management.base import BaseCommand
from reports.models import ReportReview
from mailing.mailer import send_review_notification

logger = logging.getLogger(__name__)

class Command(BaseCommand):
    help = 'Sends pending AI review result notifications to users via email.'

    def handle(self, *args, **options):
        """
        알림 발송이 필요한 AI 리뷰를 조회하여 이메일을 발송하고,
        발송 완료 상태를 업데이트합니다.
        """
        pending_reviews = ReportReview.objects.filter(notification_sent=False)
        
        if not pending_reviews.exists():
            self.stdout.write(self.style.SUCCESS("발송할 리뷰 알림이 없습니다."))
            return

        self.stdout.write(f"총 {pending_reviews.count()}개의 리뷰 알림을 발송합니다.")
        
        success_count = 0
        fail_count = 0

        for review in pending_reviews:
            try:
                # 이메일 발송 함수 호출
                send_review_notification(review)
                
                # 발송 성공 시, 플래그 업데이트
                review.notification_sent = True
                review.save(update_fields=['notification_sent'])
                
                self.stdout.write(self.style.SUCCESS(f"✅ {review.user.username}님에게 리뷰 알림을 성공적으로 발송했습니다. (리뷰 ID: {review.id})"))
                success_count += 1
            
            except Exception as e:
                # 메일러에서 발생한 예외 처리
                self.stderr.write(self.style.ERROR(f"❌ {review.user.username}님에게 리뷰 알림 발송 중 오류가 발생했습니다. (리뷰 ID: {review.id})"))
                logger.error(f"Failed to send notification for review {review.id}: {e}", exc_info=True)
                fail_count += 1

        self.stdout.write("-" * 30)
        self.stdout.write(self.style.SUCCESS(f"총 {success_count}건의 알림을 성공적으로 발송했습니다."))
        if fail_count > 0:
            self.stdout.write(self.style.WARNING(f"총 {fail_count}건의 알림이 발송에 실패했습니다. 로그를 확인해주세요."))
        self.stdout.write("-" * 30)
</code></pre>
            <h3><span class="tag tag-created">Created</span> reports/migrations/0005_reportreview.py</h3>
            <pre><code># Generated by Django 5.1.6 on 2025-11-17 08:27

import django.db.models.deletion
from django.conf import settings
from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('reports', '0004_weeklyreportpersonalcomment'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='ReportReview',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('year', models.IntegerField(verbose_name='년도')),
                ('week_number', models.IntegerField(verbose_name='주차')),
                ('review_content', models.JSONField(verbose_name='AI 리뷰 내용')),
                ('notification_sent', models.BooleanField(default=False, verbose_name='알림 발송 여부')),
                ('created_at', models.DateTimeField(auto_now_add=True, verbose_name='생성일시')),
                ('updated_at', models.DateTimeField(auto_now=True, verbose_name='수정일시')),
                ('user', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='report_reviews', to=settings.AUTH_USER_MODEL, verbose_name='리뷰 대상자')),
            ],
            options={
                'verbose_name': 'AI 리뷰 결과',
                'verbose_name_plural': 'AI 리뷰 결과 목록',
                'ordering': ['-year', '-week_number', 'user'],
                'unique_together': {('user', 'year', 'week_number')},
            },
        ),
    ]
</code></pre>
        </div>
    </div>
</body>
</html>